# 다른 사람 풀이 1
def solution(msg):
    dic, answer, i, s = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'], [], 0, msg[0]

    while i != len(msg): # msg의 길이가 i와 같지 않게, msg의 마지막 요소보다 i가 커지면 종료
        if s in dic: # 사전에 글자가 있으면
            if i != len(msg)-1: # msg의 마지막 요소의 인덱스가 아닐때
                i += 1 # i를 증가
            else:
                answer.append(dic.index(s)+1) # msg의 마지막 요소면 answer에 색인 번호 append
                break
            s += msg[i] # 비교하는 s에 다음 글자를 더해준다.
        else: # 사전에 글자가 없으면
            dic.append(s) # 사전에 해당 글자 s를 추가하고
            answer.append(dic.index(s[:-1])+1) # 마지막 글자의 색인 번호 append
            s = msg[i] # s를 마지막 글자로 변경
    return answer
# 테스트 1 〉	통과 (0.01ms, 10.1MB)
# 테스트 2 〉	통과 (0.03ms, 10.4MB)
# 테스트 3 〉	통과 (0.02ms, 10.1MB)
# 테스트 4 〉	통과 (1.16ms, 10.2MB)
# 테스트 5 〉	통과 (0.04ms, 9.98MB)
# 테스트 6 〉	통과 (1.79ms, 10.2MB)
# 테스트 7 〉	통과 (0.85ms, 10.3MB)
# 테스트 8 〉	통과 (1.17ms, 10.3MB)
# 테스트 9 〉	통과 (0.00ms, 10.2MB)
# 테스트 10 〉	통과 (1.10ms, 10.2MB)
# 테스트 11 〉	통과 (1.10ms, 10.4MB)
# 테스트 12 〉	통과 (1.66ms, 10.2MB)
# 테스트 13 〉	통과 (4.22ms, 10.1MB)
# 테스트 14 〉	통과 (4.02ms, 10.2MB)
# 테스트 15 〉	통과 (4.03ms, 10.2MB)
# 테스트 16 〉	통과 (2.49ms, 10.2MB)
# 테스트 17 〉	통과 (1.53ms, 10.2MB)
# 테스트 18 〉	통과 (0.34ms, 10.4MB)
# 테스트 19 〉	통과 (0.55ms, 10.3MB)
# 테스트 20 〉	통과 (1.61ms, 10.2MB)

# 다른 사람 풀이 2
def solution(msg):
    alphabet = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
    d = {k:v for (k,v) in zip(alphabet, list(range(1,27)))} # 알파벳으로 색인 번호를 추가해 사전을 만듦
    answer = []

    while True:
        if msg in d: # 사전에 msg가 있으면
            answer.append(d[msg]) # 정답에 색인 번호 append
            break
        for i in range(1, len(msg)+1):
            if msg[0:i] not in d: # msg 앞부터 i까지가 사전에 없으면
                answer.append(d[msg[0:i-1]]) # 정답에 msg 앞부터 i-1(새 글자)까지의 색인 번호 append, 1자리도 가능, 2자리도 가능
                d[msg[0:i]] = len(d)+1 # 색인 번호를 사전의 길이 + 1만큼하여 새 글자를 사전에 추가
                msg = msg[i-1:] # 사전에 등록한 글자만큼 msg 앞을 잘라냄
                break

    return answer
# 테스트 1 〉	통과 (0.02ms, 10.2MB)
# 테스트 2 〉	통과 (0.04ms, 10.4MB)
# 테스트 3 〉	통과 (0.03ms, 10.2MB)
# 테스트 4 〉	통과 (0.32ms, 10.4MB)
# 테스트 5 〉	통과 (0.04ms, 10.2MB)
# 테스트 6 〉	통과 (0.42ms, 10.2MB)
# 테스트 7 〉	통과 (0.22ms, 10.2MB)
# 테스트 8 〉	통과 (0.47ms, 10.2MB)
# 테스트 9 〉	통과 (0.01ms, 10.2MB)
# 테스트 10 〉	통과 (0.30ms, 10.2MB)
# 테스트 11 〉	통과 (0.33ms, 10.3MB)
# 테스트 12 〉	통과 (0.66ms, 10.3MB)
# 테스트 13 〉	통과 (0.86ms, 10.3MB)
# 테스트 14 〉	통과 (0.76ms, 10.3MB)
# 테스트 15 〉	통과 (1.08ms, 10.3MB)
# 테스트 16 〉	통과 (0.56ms, 10.2MB)
# 테스트 17 〉	통과 (0.39ms, 10.2MB)
# 테스트 18 〉	통과 (0.11ms, 10.2MB)
# 테스트 19 〉	통과 (0.32ms, 10.2MB)
# 테스트 20 〉	통과 (0.56ms, 10.2MB)


# 다른 사람 풀이 3
def solution(msg):
    a = []
    msg += '_'
    s = list('_ABCDEFGHIJKLMNOPQRSTUVWXYZ')
    while len(msg) > 1: # msg가 1자리가 될 때까지
        i = 0
        while msg[:-i] not in s: # 뒤에서부터 하나씩 줄여가면서 사전에 있는 글자를 찾는다.
            i += 1
        a += [s.index(msg[:-i])] # 정답에 해당 글자의 색인 번호를 추가
        s += [msg[:-i+1]] # (사전에 있는 글자 + 다음 글자 조합)을 사전에 추가
        msg = msg[-i:] # 방금 확인한 글자를 삭제
    return a
# 테스트 1 〉	통과 (0.02ms, 10.3MB)
# 테스트 2 〉	통과 (0.14ms, 10.2MB)
# 테스트 3 〉	통과 (0.08ms, 10.3MB)
# 테스트 4 〉	통과 (72.40ms, 10.3MB)
# 테스트 5 〉	통과 (0.24ms, 10.4MB)
# 테스트 6 〉	통과 (153.23ms, 10.3MB)
# 테스트 7 〉	통과 (17.90ms, 10.3MB)
# 테스트 8 〉	통과 (51.89ms, 10.2MB)
# 테스트 9 〉	통과 (0.01ms, 10.2MB)
# 테스트 10 〉	통과 (56.42ms, 10.2MB)
# 테스트 11 〉	통과 (70.50ms, 10.2MB)
# 테스트 12 〉	통과 (134.81ms, 10.2MB)
# 테스트 13 〉	통과 (612.97ms, 10.2MB)
# 테스트 14 〉	통과 (541.02ms, 10.2MB)
# 테스트 15 〉	통과 (556.17ms, 10.3MB)
# 테스트 16 〉	통과 (293.25ms, 10.4MB)
# 테스트 17 〉	통과 (122.10ms, 10.3MB)
# 테스트 18 〉	통과 (7.23ms, 10.2MB)
# 테스트 19 〉	통과 (23.27ms, 10.2MB)
# 테스트 20 〉	통과 (115.70ms, 10.2MB)